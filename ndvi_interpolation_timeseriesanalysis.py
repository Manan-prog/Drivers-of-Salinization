# -*- coding: utf-8 -*-
"""NDVI_Interpolation_TimeSeriesAnalysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bdcqD-rFT8mVkqMMiRl1x7Hh1mMySUB7
"""

from google.colab import drive
drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.

# %cd /content/drive/MyDrive/Chapter2/NDVI_Time_Series/Code

import numpy as np
import pandas as pd
from statsmodels.tsa.seasonal import STL
from scipy.interpolate import interp1d
from tqdm import tqdm  # Import tqdm for the progress bar

# Load the input CSV file
input_file = "NDVI_Complete_TimeSeries.csv"  # Replace with your file path
data = pd.read_csv(input_file)

# Extract latitude and longitude columns
lat_lon = data.iloc[:, :2]

# Define the number of columns per repetition and the total number of repetitions
columns_per_repetition = 19
total_repetitions = 5

# Calculate the total number of rows and iterations
total_rows = len(data)
total_iterations = total_rows * total_repetitions

# Initialize tqdm progress bar
progress_bar = tqdm(total=total_iterations, desc='Interpolating Data', position=0)

# Interpolate missing values using seasonal decomposition
interpolated_data = data.copy()  # Create a copy of the original data to store interpolated values

for repetition in range(total_repetitions):
    start_column = repetition * columns_per_repetition + 2  # Skip the latitude and longitude columns

    for index, row in interpolated_data.iterrows():
        # Update progress bar description
        progress_bar.set_description(f'Interpolating Row {index+1}/{total_rows}, Repetition {repetition+1}/{total_repetitions}')

        # Extract time series data for the current repetition
        time_series = row.iloc[start_column:start_column + columns_per_repetition]

        # Check if there are missing values in the time series
        if time_series.isnull().any():
            # If there are missing values, perform interpolation

            # Find indices of known values
            known_indices = ~time_series.isnull()
            known_values = time_series[known_indices]
            missing_indices = ~known_indices

            # Create a numeric index ranging from 0 to the length of the time series
            numeric_index = np.arange(len(time_series))

            # Interpolate missing values using known values
            interpolator = interp1d(numeric_index[known_indices], known_values, kind='linear', fill_value='extrapolate')
            interpolated_values = interpolator(numeric_index[missing_indices])

            # Update the time series with interpolated values
            time_series[missing_indices] = interpolated_values

        # Update the corresponding row in the interpolated data
        interpolated_data.iloc[index, start_column:start_column + columns_per_repetition] = time_series

        # Update progress bar
        progress_bar.update(1)

# Close the progress bar
progress_bar.close()

# Concatenate latitude, longitude, and interpolated time series data
interpolated_data = pd.concat([lat_lon, interpolated_data.iloc[:, 2:]], axis=1)

# Save the updated DataFrame to a new CSV file
interpolated_data.to_csv("interpolated_data.csv", index=False)

"""# Interpolated Values between 0 and 1 only, use code below:"""

# import numpy as np
# import pandas as pd
# from statsmodels.tsa.seasonal import STL
# from scipy.interpolate import interp1d
# from tqdm import tqdm  # Import tqdm for the progress bar

# # Load the input CSV file
# input_file = "NDVI_Complete_TimeSeries.csv"  # Replace with your file path
# data = pd.read_csv(input_file)

# # Extract latitude and longitude columns
# lat_lon = data.iloc[:, :2]

# # Define the number of columns per repetition and the total number of repetitions
# columns_per_repetition = 19
# total_repetitions = 5

# # Calculate the total number of rows and iterations
# total_rows = len(data)
# total_iterations = total_rows * total_repetitions

# # Initialize tqdm progress bar
# progress_bar = tqdm(total=total_iterations, desc='Interpolating Data', position=0)

# # Interpolate missing values using seasonal decomposition
# interpolated_data = data.copy()  # Create a copy of the original data to store interpolated values

# for repetition in range(total_repetitions):
#     start_column = repetition * columns_per_repetition + 2  # Skip the latitude and longitude columns

#     for index, row in interpolated_data.iterrows():
#         # Update progress bar description
#         progress_bar.set_description(f'Interpolating Row {index+1}/{total_rows}, Repetition {repetition+1}/{total_repetitions}')

#         # Extract time series data for the current repetition
#         time_series = row.iloc[start_column:start_column + columns_per_repetition]

#         # Check if there are missing values in the time series
#         if time_series.isnull().any():
#             # If there are missing values, perform interpolation

#             # Find indices of known values
#             known_indices = ~time_series.isnull()
#             known_values = time_series[known_indices]
#             missing_indices = ~known_indices

#             # Create a numeric index ranging from 0 to the length of the time series
#             numeric_index = np.arange(len(time_series))

#             # Interpolate missing values using known values
#             interpolator = interp1d(numeric_index[known_indices], known_values, kind='quadratic', fill_value='extrapolate')
#             interpolated_values = interpolator(numeric_index[missing_indices])

#             # Clip interpolated values between 0 and 1
#             interpolated_values = np.clip(interpolated_values, 0, 1)

#             # Update the time series with interpolated values
#             time_series[missing_indices] = interpolated_values

#         # Update the corresponding row in the interpolated data
#         interpolated_data.iloc[index, start_column:start_column + columns_per_repetition] = time_series

#         # Update progress bar
#         progress_bar.update(1)

# # Close the progress bar
# progress_bar.close()

# # Concatenate latitude, longitude, and interpolated time series data
# interpolated_data = pd.concat([lat_lon, interpolated_data.iloc[:, 2:]], axis=1)

# # Save the updated DataFrame to a new CSV file
# interpolated_data.to_csv("NDVI_Quad_interpolated_data_0_1.csv", index=False)

"""## USING TIME SERIES SEASONAL DECOMPOSITION"""

# import numpy as np
# import pandas as pd
# from statsmodels.tsa.seasonal import STL
# from scipy.interpolate import interp1d
# from tqdm import tqdm  # Import tqdm for the progress bar

# # Load the input CSV file
# input_file = "NDVI_Complete_TimeSeries.csv"  # Replace with your file path
# data = pd.read_csv(input_file)

# # Extract latitude and longitude columns
# lat_lon = data.iloc[:, :2]

# # Define the number of columns per repetition and the total number of repetitions
# columns_per_repetition = 19
# total_repetitions = 5

# # Calculate the total number of rows and iterations
# total_rows = len(data)
# total_iterations = total_rows * total_repetitions

# # Initialize tqdm progress bar
# progress_bar = tqdm(total=total_iterations, desc='Interpolating Data', position=0)

# # Interpolate missing values using seasonal decomposition
# interpolated_data = data.copy()  # Create a copy of the original data to store interpolated values

# for repetition in range(total_repetitions):
#     start_column = repetition * columns_per_repetition + 2  # Skip the latitude and longitude columns

#     for index, row in interpolated_data.iterrows():
#         # Update progress bar description
#         progress_bar.set_description(f'Interpolating Row {index+1}/{total_rows}, Repetition {repetition+1}/{total_repetitions}')

#         # Extract time series data for the current repetition
#         time_series = row.iloc[start_column:start_column + columns_per_repetition].copy()  # Make a copy to avoid modifying the original data

#         # Check if there are missing values in the time series
#         if time_series.isnull().any():
#             # If there are missing values, perform seasonal decomposition

#             # Perform seasonal decomposition
#             stl = STL(time_series, period=19)  # Set the seasonal period to 19 for 19 data points per year
#             result = stl.fit()

#             # Interpolate missing values in each component separately
#             interpolated_seasonal = interp1d(np.arange(len(time_series)), result.seasonal, kind='linear', fill_value='extrapolate')(np.arange(len(time_series)))
#             interpolated_trend = interp1d(np.arange(len(time_series)), result.trend, kind='linear', fill_value='extrapolate')(np.arange(len(time_series)))
#             interpolated_residual = interp1d(np.arange(len(time_series)), result.resid, kind='linear', fill_value='extrapolate')(np.arange(len(time_series)))

#             # Normalize interpolated values to stay within the range of 0 and 1
#             interpolated_seasonal = np.clip(interpolated_seasonal, 0, 1)
#             interpolated_trend = np.clip(interpolated_trend, 0, 1)
#             interpolated_residual = np.clip(interpolated_residual, 0, 1)

#             # Reconstruct the time series with interpolated values
#             time_series = interpolated_seasonal + interpolated_trend + interpolated_residual

#             # Update the corresponding row in the interpolated data
#             interpolated_data.iloc[index, start_column:start_column + columns_per_repetition] = time_series

#         # Update progress bar
#         progress_bar.update(1)

# # Close the progress bar
# progress_bar.close()

# # Save the updated DataFrame to a new CSV file
# interpolated_data.to_csv("Checkinglast_interpolated_data.csv", index=False)

